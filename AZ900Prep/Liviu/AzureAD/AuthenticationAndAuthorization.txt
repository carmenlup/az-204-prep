Azure AD is used as Identity Provider

APIs and authorization
	- Access tokens will be used to call the APIs
	
Libraries:
	- Microsoft authentication library
	
OAuth 2.0
	- industry standard protocol for authorization
	- UC: User that is defined in Az AD, will log into the web application. The app will authenticate the user.
	The App will access the a Storage Account on behalf of the user.
	OAuth 2.0 - This is known as the Authorization Code Flow 
	- the app exchanges the authorization code for an access tokens

Auhtorization Code flow - more details
	- Resource owner - the user who has access to the protected resource
	- Client - The app requesting access to the protected resource
	- Resource server - The Storage Account
	- Authorization server	(Microsoft Identity platform)
		- will provide the access token
	
	- How the auth flow works:
		1. The web app makes a call to the Authorization server
		2. The auth server will pass the Authorization Code back to the application, by calling the redirect URI that was specified at step 1
		3. The app will use the Auth Code to call the Authorization server to exchange that code for the Access Token
		4. The the app will be able to call the Storage Account APIs, using the Access Token
		
Review the different ways of accessing the Storage Account, which we implemented so far:
	- using the connection string. This includes the access key in the URL, which gives your full permissions to that Storage Account and all its services
	- using an Application Object identity.
		- we also used the Client Credentials Flow to get the Access token from Postman
	- using Managed Identity. 
	
Lab ASP.Net - Adding Authentication
	- create a web app
	- create an App Object from the portal 
	- create a section in your appsettings.json where to define properties for:
		- the app object ClientId, TenantId
		- "Instance": "https://login.microsoftonline.com".The  url that will be used for authentication
		- add 2 more properties in the appsettings, AzureAd section:
		"CallbackPath":"/signin-oidc",
		"SignedOutCallbackPath": "/signout-oidc"
		OIDC = Open ID Connect. Protocol that is build on top of OAuth 
	- install the Microsoft.Identity.Web package
	- from Program.cs: builder.Services.AddMicrosoftIdentityWebAppAuthentication(builder.Configuration, "your setting section defined above");
	- app.UseAuthentication
	- add [Authorize] for the Index page
	- Portal: go to your App Object -> Authentication
		- Add a platform -> select Web
		- define the Redirect URIs (for now just copy the URL of your localhost app) https://localhost:7259/ + callbackPath
		- define the Front-Channel ogout URL: https://localhost:7259/signout-oidc
		- check ID tokens checkbox
		- click Configure
		
Add Sigh-Out feature:
	- install package microsoft.identity.web.ui
		We're gonna use the sign-in, sign-out controllers that comes with these packages
	- Program.cs: 
		- builder.Services.AddControllersWithViews();. Because it depends on the MVC pattern
		- Add MvcOptions to the razor pages. Add it after the above line. 
			builder.Services.AddRazorPages().AddMvcOptions(opt => {var policy = new AuthorizationPolicyBuilder().RequireAuthenticatedUser().Build();
			opt.Filters.Add(new AuthorizedFilter(policy));
			}).AddMicrosoftIdentityUI();
		- remove the [Authorize] attribute from Index, since we added the Auth policy for evrything
		- Use endpoints, since we added MVC:
			app.UseEndpoints(endpoints =>
			{
				endpoints.MapControllerRoute(
					name: "default",
					pattern: "{controller=Home}/{action=Index}/{id?}"
				);
			});
		- Add Scaffolded Item to the project
		- Pick Identity
		- Select Account/Login and /Logout
		- Add DataContext
		- Check SQL Lite
			This installs some nuget packages required to work with identities. Will add some new pages + partial pages. Will also update the Program.cs and add the required services
		- Do some changes in the _LoginPartial class, in order to use the Microsoft.Identity.Web.UI controllers:
		@if (User.Identity.IsAuthenticated)
		{
			<li class="nav-item">
				<a id="manage" class="nav-link text-dark" title="Manage">Hello @User.Identity.Name!</a>
			</li>
			<li class="nav-item">
					<a class="nav-link text-dark" asp-area="MicrosoftIdentity" asp-controller="Account" asp-action="SignOut">SignOut</a>
			</li>
		}
		else
		{
			<li class="nav-item">
					<a class="nav-link text-dark" id="login" asp-area="MicrosoftIdentity" asp-controller="Account" asp-action="SignIn">Login</a>
			</li>
		}		
		- add _LoginPartial to your _Layout.cshtml
		
Get User Claims
	- key-value pairs containing information about the user
	- Display User.Claims on the index page
	
Get Group Claims
	- Portal - Go to your App Object -> Token Configuration
	- From there you can define what Claims to be passed to your app, along with the ID token
	- select Add Group Claim and select Security Groups and Group ID
	- Manifest: Here you'll see all the properties of your App Object. 
Other claims
	- Portal - App Object - Token Configuration
	- Add claims - Select the token type (ID in our case)
	- Choose the claims you want to be provided along with the token ID

AUTHORIZATION	
LAB Get Access Token
	- Get token for the logged in user
	- First of all, go to your Storage account and set Role Assignments for the user you'll use to log into your application (First User - UserA@chifanionutgmail.onmicrosoft.com)
	- Program.cs	
		- need to insure that our pogram can automatically work with Access Token
		- Add a scope. string[] scopes = new string[] {"https://storage.azure.com/user_impersonation"};
		- where we add the service .AddMicrosoftIdentityWebAppAuthentication() we'll call .EnableTokenAcquisitionToCallDownstreamApi(scope).AddInMemoryTokenCaches();
		
		- Even the application needs some permissions, in order to access the storage account on behalf of the user
		- go go App Object - API Permissions - Add permissions
		- choose Azure Storage -> select Delegated permissions -> select user_impersonation
		- Then go to the Authentication section and check Access Token
	
	Inspect the Access Token for the sake of demonstration (normally you'll not work directly with it):
		- Inject ITokenAcquisition interface into Index page
		- In OnGet() method, get the token
		-  AccessToken = await _tokenAcquisition.GetAccessTokenForUserAsync(scopes);
		- but we get an error: One client credential type required either: ClientSecret, Certificate, ClientAssertion or AppTokenProvider must be defined when creating a Confidential Client.
		- this is because the  authorization code flow need to exchange the Auth Code for the Token, and for this it needs a secret
		- Edit the appsettings.json AzureAd section and add the ClientSecret prop. Generate a value from your App Object
	
	Using an access token:
		- get the access token credentials using this class: var credentials = new TokenAcquisitionTokenCredential(TokenAcquisition);
		- you don't need to specify any scopes. This class will give you the Access Token based on the logged in user permissions
		- you can use this Token Credentials to call the Storage Account, on behalf of the logged in user: var client = new BlobClient(blobUri, credentials);
		
		
			