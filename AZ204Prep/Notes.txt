- he's showing how to deploy web app from VS Code
	- publish to local folder
	- install extension Web App Service
	- from VS Code right click on the folder -> Deploy to Web App

Availabl runtimes
	.Net
	Java
	Python
	Node
	PHP
	
Operating systems
	Windows
	Linux
Need to find what is the difference??

- How to enable Publish from VS
	- go to the Webb App - Settings - Configuration - Enable SCM Basic Auth Publishing Credentials

- App Service plan
	Shared:
		Free: 60 minutes of compute per day
		Shared
	Dedicaed:
		Basic
		Standard
		Premium
		Premium V2
		Premium V3
	Isolated
		Isolated
		Isolated V2

	SQL server and DB
		- set server firewall in order to allow connections

	Using TLS

	How to use custom domain names and certificates
		1. Upgrade service plan to minimum Basic
		2. Go to the web app - Custom Domains 
			- from there you copy the so called Records (some info that will help Azure to validate the domain) and add them onto the external provider platform (dns records)
			- click Validate & Add

	Service plan
		- Free & Shared: you share the VMs. Limited computing time
		- Basic and Higher: dedicated VMs, no limitation in term of computing time

	Auto Scaling
		- With standard you can scale based on Rules
			- Azure monitor will check your resources and monitor some metrics 
			- Set min - max instances
			- Add scale rules
			- The monitored metrics is for the entire app service infrastructure (NOT for a single VM). 

		- With premium you can have automatic scaling based on traffic 

	Deployment Slots
		- From Standard service plan or higher
		- When creating configuration settings that should be available only for that specific deployment slot (not swapable), you need to check Deployment Slot Setting
		Benefits of deploying to non-production slots:
			- feature validation
			- The instances are warmed up during the swap operations - resulting in no downtime for the prod env. 
				You can even configure auto-swap when pre-swap validation is not required
				how to enable auto-swap: go to the slot you want (stage) -> Settings -Configuration -> enable Auto-Swap
				!!! Auto swap isn't currently supported in web apps on Linux and Web App for Containers.
			- "roll-back" fast, by swapping again with staging
		Swap operation. The steps that are executed in order to ensure no downtime:
			1. apply the target slot settings to the source slot:
				- Slot-specific app settings and connection strings, if applicable.
				- Continuous deployment settings, if enabled.
				- App Service authentication settings, if enabled.
			This trigger a restart for the source slot instances
			2. Wait for the source slot instances to restart. If any instance fails, the swap operation reverts all changes to the source slot and stops the operation
			3. If local cache is enabled, then trigger cache initialization, which also trigger instances restart
			4. If auto-swap is enabled, trigger Application initialization by making http request to the root of the source slot, for each instance
				- if the instance returns http response, it's considered warmed up
			5. If all the instances of the source slot are warmed up, swap the slots by switching the routing rules. After this step, the target slot has the app that was previously warmed up.
			6. Now that the source slot has the pre-swap app previously in the target slot, perform the same operation by applying all settings and restarting the instances.

			!!! All the warm-up operations happen on the source slot. So make sure the Production slot is alway set as target.
		To make all settings swappable, add this app setting: WEBSITE_OVERRIDE_PRESERVE_DEFAULT_STICKY_SLOT_SETTINGS: false
	
		Swap with preview:
			- it's the same swap operation, but it will pause after the settings are applied and the warm up finishes on the source slot. In this way you can validate the source slot
		
		Specify custom warm-up actions:
			Some apps might require custom warm-up actions before the swap. The applicationInitialization configuration element in web.config lets you specify custom initialization actions. 
			<system.webServer>
			    <applicationInitialization>
			        <add initializationPage="/" hostName="[app hostname]" />
			        <add initializationPage="/Home/About" hostName="[app hostname]" />
			    </applicationInitialization>
			</system.webServer>

		You can also customize the warm-up behavior with one or both of the following app settings:
			- WEBSITE_SWAP_WARMUP_PING_PATH: /statuscheck
			- WEBSITE_SWAP_WARMUP_PING_STATUSES: 200, 201, etc.
			- WEBSITE_WARMUP_PATH: /statuscheck (A relative path on the site that should be pinged whenever the site restarts )

		Route traffic:
			- You can route a portion of the traffic that comes to production to another slot. (usefull when releasing a new update and want some feedback from a couple of users)
			- A client is routed to the same slot during the lifetime of the current session (the x-ms-routing-name cookie is added to the request)
			- Manually routing by using the query parameters: <webappname>.azurewebsites.net/?x-ms-routing-name=staging. After accessing the link, the cookie header is set and the user will be pinned to that slot


	Azure app service Logging 
		- From Web app level - Application Service Logs
		- Enable/Disable: 
			Application Logs (saved to File sistem or Blob) / 
			Web Server Logging (File sistem or Storage. You can specify retention days) / 
			Detailed error message / 
			Failed request tracing
		- you can connect to the log stream and view the live logs (how show how to do that from VS Code)
	
	Publish Code from Git-based repository
		- Go to deployment center - Select Github and authenticate - select repo and main branch 
		- there will be an workflow created on gitgub that will publish to azure when there are changes on the branch

	Azure App Config
		- store key-value pairs: Application settings & feature flags
		- usefull for storing common configuration settings that are used by multiple apps
		
		Config settings: https://learn.microsoft.com/en-us/azure/azure-app-configuration/quickstart-aspnet-core-app
			- create the resource
			- use : char to create setting sections. e.g. WebApp:ConnectionStrings:MyDbConnection
			- dotnet add package Microsoft.Azure.AppConfiguration.AspNetCore
			- add the connection string to the App Config service ( You can find the connection string under Access Keys of your App Configuration store in the Azure portal.)
			- From Program.cs:
				string connectionString = builder.Configuration.GetConnectionString("AppConfig");
				builder.Configuration.AddAzureAppConfiguration(connectionString);
				!! This code will connect to your App Configuration store using a connection string and load all key-values that have no labels. 
				WHY only the ones with no label?? 
					=> You can define filters based on key name or label.Only the settings that meet the filters will be loaded in the app (de default filter ignores the ones with no label)
			- In programm.cs you can bind a setting section to a strongly typed class created by you
				// Bind configuration "TestApp:Settings" section to the Settings object
				builder.Services.Configure<Settings>(builder.Configuration.GetSection("TestApp:Settings"));
			- Then you can inject the config options whenever where you want to use them: IOptionsSnapshot<StyleSettings> options

		Feature flags: https://learn.microsoft.com/en-us/azure/azure-app-configuration/quickstart-feature-flag-aspnet-core
			- Feature management section
			- dotnet add package Microsoft.FeatureManagement.AspNetCore
			- need to add:
				// Add feature management to the container of services.
				builder.Services.AddFeatureManagement();
			- Open Pages/_ViewImports.cshtml, and register the feature manager Tag Helper using an @addTagHelper directive.
				@addTagHelper *, Microsoft.FeatureManagement.AspNetCore
			- use the <feature name=""> directive. THis builds the html only if the feature is active. At the controller lavel you can use the attribute [FeatureGate()]

	Azure Static web app
		- nothing special learnt here. From the Create Web app screen - publish section - you choose Create Static Web app, which will direct you to a different create screen
		- 

